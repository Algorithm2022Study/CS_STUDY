
# 트랜잭션이란?
:  DB 상태를 변화시키기 위해 수행하는 작업의 단위


데이터베이스의 상태를 변화시킨다는 것은 무얼 의미하는 것일까?

: 간단하게 말해 아래 질의어(SQL)를 이용하여 데이터베이스를 접근 하는 것을 의미한다.

* SELECT, INSERT, DELETE, UPDATE


📌 트랜잭션의 특징 4가지
원자성 (Atomicity)
: All or Nothing, 트랜잭션이 데이터베이스에 모두 반영되던가 아니면 전혀 반영되지 않아야 한다는 것

: 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

일관성 (Consistency)
: 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것.

: 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

독립성 (Isolation)
: 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점.

: 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

지속성 (Durability)
: 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 점



📌 트랜잭션의 Commit, Rollback 연산
Commit
: 수행한 트랜잭션을 로그에 저장해주는 명령어. 트랜잭션이 성공적으로 완료되었고 데이터베이스가 다시 일관된 상태에 있을 때, 트랜잭션의 종료를 알려주는 연산이다.

Rollback
: 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진경우, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.



# 인덱스란?
: 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조

: 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장됨.



📌 인덱스를 사용하는 이유 
: 테이블에 데이터들이 인덱스의 가장 큰 특징은 데이터들이 정렬이 되어있다는 점 (이 특징으로 조건 검색이라는 영역에서 굉장한 장점)

1) 조건 검색 WHERE 절의 효율성
: 테이블에 데이터가 쌓이면 테이블의 레코드(행)는 순서 없이 저장된다. 이렇게 되면 WHERE절에 맞는 데이터들을 찾아낼 때 처음부터 끝까지 읽어서 검색 조건과 맞는지 비교해야 한다. 이것을 풀 스캔이라고 한다. 하지만 인덱스 테이블 스캔 시 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건에 맞는 데이터들을 빠르게 찾아낼 수 있다.

2) 정렬 ORDER BY 절의 효율성
: 인덱스를 사용하면 부하가 많이 걸리는 ORDER BY에 의한 정렬 과정을 피할 수 있다.

3) MIN, MAX의 효율적인 처리가 가능하다
: MIN값과 MAX값을 레코드의 시작 값과 끝 값 한 건씩만 가져오면 되기 때문에 Full Table Scan으로 테이블을 모두 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있다.



📌 인덱스 단점
: 인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지시켜줘야 한다는 점이다. 그렇기에 레코드 내에 데이터 값이 바뀌는 부분이라면 악영향을 미친다.

1) 인덱스는 DML에 취약
: INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값들을 다시 정렬을 해야 한다. 그리고 인덱스 테이블, 원본 테이블 이렇게 두 군데의 데이터 수정을 해줘야 한다는 단점도 발생한다. 그렇기 때문에 DML이 빈번한 테이블보다 검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋다.

2) 적은 데이터 처리할 경우에 불리
: 예시를 들자면 1개의 데이터가 있는 테이블과 100만 개의 데이터가 들어 있는 테이블이 있다고 하자. 100만 개의 데이터가 들어있는 테이블이라면 풀 스캔보다는 인덱스 스캔이 유리하겠지만, 1개의 데이터가 들어있는 테이블은 굳이 인덱스 스캔 없이 풀 스캔이 빠를 것이다. 

3) 속도 향상을 위해 인덱스를 많이 만드는 것은 안좋음
: 인덱스를 관리하기 위해서는 저장공간이 추가로 필요하다. 속도 향상에 비해 단점들의 COST를 비교해서 인덱스를 만들지 말지를 정해야 한다.

# NoSql이란?
: NoSQL은 비관계형 데이터베이스를 지칭한다. 즉, 관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.



📌 NoSQL의 특징
1) RDBMS와 달리 데이터 간의 관계를 정의하지 않는다.

: RDBMS는 데이터 관계를 외래키 등으로 정의하고 JOIN 연산을 수행할 수 있지만, NoSQL은 JOIN 연산이 불가능하다.



2) RDBMS에 비해 대용량의 데이터를 저장할 수 있다.

: 페타바이트 급의 대용량 데이터를 저장할 수 있다.



3) 분산형 구조이다.

: 여러 곳의 서버에 데이터를 분산 저장해 특정 서버에 장애가 발생했을 때도 데이터 유실 혹은 서비스 중지가 발생하지 않도록 한다.



4) 고정되지 않은 테이블 스키마를 갖는다.

: RDBMS와 달리 테이블의 스키마가 유동적이다. 데이터를 저장하는 칼럼이 각기 다른 이름과 다른 데이터 타입을 갖는 것이 허용된다.



📌 NoSQL의 장점
RDBMS에 비해 저렴한 비용으로 분산처리와 병렬 처리 가능
비정형 데이터 구조 설계로 설계 비용 감소
Big Data 처리에 효과적
가변적인 구조로 데이터 저장이 가능
데이터 모델의 유연한 변화가 가능

📌 NoSQL의 단점
데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
데이터 일관성이 항상 보장되지 않음

# OSI 7계층이란?
: 개방형 시스템 상호 연결 모델의 표준

: 실제 인터넷에서 사용되는 TCP/IP 는 OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화한 것

작동 원리
OSI 7계층은 응용, 표현, 세션, 전송, 네트워크, 데이터링크, 물리계층으로 나뉨.
전송 시 7계층에서 1계층으로 각각의 층마다 인식할 수 있어야 하는 헤더를 붙임(캡슐화)
수신 시 1계층에서 7계층으로 헤더를 떼어냄(디캡슐화)
출발지에서 데이터가 전송될 때 헤더가 추가되는데 2계층에서만 오류제어를 위해 꼬리부분에 추가됌
물리계층에서 1,0 의 신호가 되어 전송매체(동축케이블, 광섬유 등)을 통해 전송


📌 물리계층(Physical Layer)
: 7계층 중 최하위 계층. 데이터는 0과 1의 비트열, 즉 On, Off의 전기적 신호 상태로 이루어져 해당 계층은 단지 데이터를 전달.

* 단지 데이터 전달의 역할을 할 뿐이라 알고리즘, 오류제어 기능이 없음

📌 데이터링크 계층(Data-Link Layer)
: 물리적인 연결을 통하여 인접한 두 장치 간의 신뢰성 있는 정보 전송을 담당(Point-To-Point 전송), 안전한 정보 전달위해 오류 처리나 재전송 기능이 존재

* MAC 주소를 통해서 통신

* 데이터 링크 계층에서 데이터 단위는 프레임(Frame)

📌 네트워크 계층(Network Layer)
: 중계 노드를 통해 전송하는 경우 어떻게 중계할 건지 규정, 라우팅 기능을 맡아 목적지까지 안전하고 빠르게 데이터 보내는 기능 가짐      (최적경로 설정 가능)

: 컴퓨터에게 데이터를 전송할지 주소를 갖고 있어서 통신가능(=우리가 자주 듣는 IP 주소가 바로 네트워크 계층 헤더에 속함)



* 네트워크 계층에서 데이터 단위는 패킷(Packet)

* 장비로는 라우터, L3 스위치가 있음

📌 전송 계층(Transport Layer)
: 종단 간 신뢰성 있고 정확한 데이터 전송을 담당, 오류검출 및 복구, 흐름제어와 중복검사 등을 수행

* 데이터 전송을 위해서 Port 번호를 사용함.(대표적인 프로토콜로 TCP와 UDP가 있음)

* 전송 계층에서 데이터 단위는 세그먼트(Segment)

📌 세션 계층(Session Layer)
: 통신 장치 간 상호작용 및 동기화를 제공, 연결 세션에서 데이터 교환과 에러 발생 시의 복구를 관리

📌 표현 계층(Presentation Layer)
: 데이터를 어떻게 표현할지 정하는 역할을 하는 계층

* 3가지 기능

송신자에서 온 데이터를 해석하기 위한 응용계층 데이터 부호화, 변화
수신자에서 데이터의 압축을 풀수 있는 방식으로 된 데이터 압축
데이터의 암호화와 복호화
📌 응용 계층(Application Layer)
: 사용자와 가장 밀접한 계층으로 인터페이스 역할, 응용 프로세스 간의 정보 교환을 담당

ex) 전자메일, 인터넷, 동영상 플레이어 등



