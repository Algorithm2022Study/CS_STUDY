ì´ë¶„íƒìƒ‰ì´ë€?
: ì´ì§„íƒìƒ‰ì´ë€ 'ì •ë ¬ëœ ìë£Œ'ë¥¼ ë°˜ìœ¼ë¡œ ìª¼ê°œê°€ë©° ì›í•˜ëŠ” ê°’ì„ ì°¾ì•„ê°€ëŠ” íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜

* ê°€ìš´ë° ì§€ì (mid)ì„ ì°¾ê³ , ê³„ì† left, right ê°’ì„ midë¥¼ ì´ìš©í•´ ê°±ì‹ í•˜ë©´ì„œ ë²”ìœ„ë¥¼ ì¢í˜€ë‚˜ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜


ìœ„ - ì´ë¶„íƒìƒ‰, ì•„ë˜ - ìˆœì°¨ íƒìƒ‰
ìµœì„ : O(1)
í‰ê· : O(log N)
ìµœì•…: O(log N) >> ë°ì´í„°ê°€ í•œ ê°œ ë‚¨ì„ ë•Œ ê¹Œì§€ ì°¾ëŠ” ê²½ìš°ê°€ ìµœì•…
```
# ì´ë¶„íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ (ì •ë°©í–¥)
def BinarySearch(arr,target):
    #L: left, R: Right, M: Mid
    L,R = 0, len(arr)-1
    while(L <= R): # L>R ë˜ë©´ íƒˆì¶œ (ë°°ì—´ì— targetì´ ì—†ë‹¤)
        M = (L + R) // 2
        if(arr[M] == target): # targetê°’ì— í•´ë‹¹í•˜ëŠ” idx ì°¾ìŒ
            return M
        elif(arr[M] > target): # target ê°’ë³´ë‹¤ ë” í´ ë•Œ
            R = M - 1 # Rì„ ì¤‘ê°„-1 ì˜ idxë¡œ ê°±ì‹  
        else: #target ê°’ë³´ë‹¤ ë” ì‘ì„ ë•Œ
            L = M + 1 # Lì„ ì¤‘ê°„+1 ì˜ idxë¡œ ê°±ì‹ 
    return -1 #ë°°ì—´ ë‚´ì— ê°’ì´ ì—†ìŒ
```
ìµœë‹¨ ê²½ë¡œ(ë‹¤ìµìŠ¤íŠ¸ë¼)ë€?
: ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°ì„ í™œìš©í•´ ìµœë‹¨ê±°ë¦¬ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜. íŠ¹ì • source ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ì ìœ¼ë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œë¥¼ ì•Œë ¤ì¤Œ



ë‹¤ìµìŠ¤íŠ¸ë¼ê°€ ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë°ì¸ ì´ìœ :

ì´ì „ì— êµ¬í–ˆë˜ ìµœë‹¨ê±°ë¦¬ë¥¼ ì´ìš©í•´ì„œ ë‹¤ìŒ ìµœë‹¨ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ê¸° ë•Œë¬¸ (DP ì¡°ê±´ì€ ë¶€ë¶„ ë¬¸ì œ ë°˜ë³µê³¼ ìµœì  ë¶€ë¶„ êµ¬ì¡°)



>> ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë° ì •ë¦¬ ê¸€


[ì•Œê³ ë¦¬ì¦˜ ê°œë… ì •ë¦¬] ë¶„í•  ì •ë³µë²• (Divide and Conquer), íƒìš• ì•Œê³ ë¦¬ì¦˜ (Greedy), ë™ì  ê³„íšë²• (Dynamic Prog

ë¶„í•  ì •ë³µë²• (Divide and Conquer) 1. ë¶„í•  ì •ë³µë²•ì´ë€? : ì£¼ì–´ì§„ ë¬¸ì œë¥¼ ì‘ê²Œ ë‚˜ëˆ„ê³ , ê°ê°ì˜ ì‘ì€ ë¬¸ì œë“¤ì„ í•´ê²°í•´ ì •ë³µí•˜ëŠ” ë°©ë²• í•´ë¥¼ êµ¬í•  ìˆ˜ ìˆì„ ë§Œí¼ ì¶©ë¶„íˆ ë” ì‘ì€ ì‚¬ë¡€ë¡œ ë‚˜ëˆ„ì–´ í•´ê²°í•œë‹¤. 2.

squidward-tentac1es.tistory.com


ìµœë‹¨ ê²½ë¡œ ì½”ë“œ êµ¬í˜„ - íŒŒì´ì¬
ì¶œë°œ ë…¸ë“œì™€, ë„ì°© ë…¸ë“œë¥¼ ì„¤ì • (ì „ì²´ ê±°ë¦¬ë¥¼ ì•Œê³  ì‹¶ì„ ë•ŒëŠ” ì¶œë°œ ë…¸ë“œë§Œ ì„¤ì •í•´ë„ ë¬´ë°©)
ì•Œê³  ìˆëŠ” ëª¨ë“  ê±°ë¦¬ ê°’ì„ ë¶€ì—¬ (Pythonì—ì„œëŠ” dictionary ê°ì²´ë¥¼ ì´ìš©í•˜ì—¬ graph í‘œí˜„)
ì¶œë°œ ë…¸ë“œë¶€í„° ì‹œì‘í•˜ì—¬, ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¸ì ‘ ë…¸ë“œë¥¼ ë°©ë¬¸, ê±°ë¦¬ë¥¼ ê³„ì‚°í•œ ë‹¤ìŒ, í˜„ì¬ ì•Œê³ ìˆëŠ” ê±°ë¦¬ë³´ë‹¤ ì§§ìœ¼ë©´ í•´ë‹¹ ê°’ìœ¼ë¡œ ê°±ì‹ 
í˜„ì¬ ë…¸ë“œì— ì¸ì ‘í•œ ëª¨ë“  ë¯¸ë°©ë¬¸ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í–ˆë‹¤ë©´, í˜„ì¬ ë…¸ë“œëŠ” ë°©ë¬¸í•œ ê²ƒì´ë¯€ë¡œ, ë¯¸ë°©ë¬¸ ì§‘í•©ì—ì„œ ì œê±°
```
import heapq  # ìš°ì„ ìˆœìœ„ í êµ¬í˜„ì„ ìœ„í•¨

def dijkstra(graph, start):
  distances = {node: float('inf') for node in graph}  # startë¡œ ë¶€í„°ì˜ ê±°ë¦¬ ê°’ì„ ì €ì¥í•˜ê¸° ìœ„í•¨
  distances[start] = 0  # ì‹œì‘ ê°’ì€ 0ì´ì–´ì•¼ í•¨
  queue = []
  heapq.heappush(queue, [distances[start], start])  # ì‹œì‘ ë…¸ë“œë¶€í„° íƒìƒ‰ ì‹œì‘ í•˜ê¸° ìœ„í•¨.

  while queue:  # queueì— ë‚¨ì•„ ìˆëŠ” ë…¸ë“œê°€ ì—†ìœ¼ë©´ ë
    current_distance, current_destination = heapq.heappop(queue)  # íƒìƒ‰ í•  ë…¸ë“œ, ê±°ë¦¬ë¥¼ ê°€ì ¸ì˜´.

    if distances[current_destination] < current_distance:  # ê¸°ì¡´ì— ìˆëŠ” ê±°ë¦¬ë³´ë‹¤ ê¸¸ë‹¤ë©´, ë³¼ í•„ìš”ë„ ì—†ìŒ
      continue
    
    for new_destination, new_distance in graph[current_destination].items():
      distance = current_distance + new_distance  # í•´ë‹¹ ë…¸ë“œë¥¼ ê±°ì³ ê°ˆ ë•Œ ê±°ë¦¬
      if distance < distances[new_destination]:  # ì•Œê³  ìˆëŠ” ê±°ë¦¬ ë³´ë‹¤ ì‘ìœ¼ë©´ ê°±ì‹ 
        distances[new_destination] = distance
        heapq.heappush(queue, [distance, new_destination])  # ë‹¤ìŒ ì¸ì ‘ ê±°ë¦¬ë¥¼ ê³„ì‚° í•˜ê¸° ìœ„í•´ íì— ì‚½ì…
    
  return distances
  
graph = {
    'A': {'B': 8, 'C': 1, 'D': 2},
    'B': {},
    'C': {'B': 5, 'D': 2},
    'D': {'E': 3, 'F': 5},
    'E': {'F': 1},
    'F': {'A': 5}
}

print(dijkstra(graph, 'A'))
```

ìµœì†Œ ë¹„ìš© (MST,  í¬ë£¨ìŠ¤ì¹¼ / í”„ë¦¼)
1) MST(Minimum Spanning Tree)
: ìµœì†Œ ë¹„ìš© ì‹ ì¥ íŠ¸ë¦¬( = ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬)ë¥¼ ëœ»í•œë‹¤.

> ë¬´ë°©í–¥ ê·¸ë˜í”„ì˜ ê°„ì„ ë“¤ì— ê°€ì¤‘ì¹˜ê°€ ì£¼ì–´ì§„ ê²½ìš°, ì—¬ëŸ¬ ì‹ ì¥ íŠ¸ë¦¬ ì¤‘ ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œì¸ ì‹ ì¥ íŠ¸ë¦¬



ì‹ ì¥íŠ¸ë¦¬ë€?

ì‹ ì¥ íŠ¸ë¦¬ : ë¬´ë°©í–¥ ê·¸ë˜í”„ G(V,E)ì—ì„œ Eì— ì†í•œ ê°„ì„ ë“¤ë¡œ ì‚¬ì´í´ì„ í¬í•¨í•˜ì§€ ì•Šìœ¼ë©´ì„œ ëª¨ë“  ì •ì  Vë¥¼ ì—°ê²°í•œ ë¶€ë¶„ ê·¸ë˜í”„
ì‹ ì¥ íŠ¸ë¦¬ì˜ íŠ¹ì§•ì€ nê°œì˜ ì •ì ì„ ê°–ëŠ” ê·¸ë˜í”„ì—ì„œ ì‹ ì¥ íŠ¸ë¦¬ì— ì†í•˜ëŠ” ê°„ì„ ì˜ ìˆ˜ëŠ” n-1ê°œì´ë©° ì‚¬ì´í´ì„ ì´ë£¨ì§€ ì•ŠëŠ”ë‹¤ëŠ” íŠ¹ì§•ì´ ìˆë‹¤.
2) í¬ë£¨ìŠ¤ì¹¼(Kruskal) - MST êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
: greedyí•˜ê²Œ(ê²°ì •ì˜ ìˆœê°„ë§ˆë‹¤ ìµœì„ ì˜ ê²°ì •ì„ í•¨ìœ¼ë¡œì¨ ìµœì¢…ì ì¸ í•´ë‹µì— ë„ë‹¬) ëª¨ë“  ì •ì ì„ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì—°ê²°í•˜ì—¬ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ êµ¬í•¨


1) í¬ë£¨ìŠ¤ì¹¼ì˜ í•µì‹¬ì€ ëª¨ë“  ê°„ì„ ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•˜ê³ ,

2) ê°„ì„ ë“¤ì„ ìˆœì„œëŒ€ë¡œ ëª¨ë“  ì •ì ì´ ì—°ê²°ë  ë•Œê¹Œì§€ ì—°ê²°

>> Union-Find ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•´ì„œ êµ¬í˜„í•  ìˆ˜ ìˆê³ , ì´ë¥¼ í†µí•´ ì‚¬ì´í´ì´ í˜•ì„± ì•ˆí•˜ë©´ì„œ ëª¨ë“  ì •ì  ì—°ê²° ê°€ëŠ¥



ì‹œê°„ ë³µì¡ë„ : O(ElogE)

//E : ê°„ì„ ì˜ ê°œìˆ˜



[í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì˜ ë™ì‘ ë°©ì‹]
1) ê·¸ë˜í”„ì˜ ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬

2)-1 ì •ë ¬ëœ ê°„ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆœì„œëŒ€ë¡œ ì„ íƒí•˜ì—¬, ê°„ì„ ì˜ ì •ì ë“¤ì„ ì—°ê²°

2)-2 ì´ë•Œ ì •ì ì„ ì—°ê²°í•˜ëŠ” ê²ƒì€ Union-Findì˜ Unionìœ¼ë¡œ êµ¬í˜„

3) ë§Œì•½ ê°„ì„ ì˜ ë‘ ì •ì  a,bê°€ ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´ ìŠ¤í‚µ

4) ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µ



> > ìµœì†Œ ë¹„ìš©ì˜ ê°„ì„ ë“¤ë§Œ ì´ìš©í•˜ì—¬ ëª¨ë“  ì •ì ì´ ì—°ê²°ë¨
```
import sys

v, e = map(int, input().split())
# ë¶€ëª¨ í…Œì´ë¸” ì´ˆê¸°í™”
parent = [0] * (v+1)
for i in range(1, v+1):
    parent[i] = i

# find ì—°ì‚°
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# union ì—°ì‚°
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# ê°„ì„  ì •ë³´ ë‹´ì„ ë¦¬ìŠ¤íŠ¸ì™€ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ê³„ì‚° ë³€ìˆ˜ ì •ì˜
edges = []
total_cost = 0

# ê°„ì„  ì •ë³´ ì£¼ì–´ì§€ê³  ë¹„ìš©ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
for _ in range(e):
    a, b, cost = map(int, input().split())
    edges.append((cost, a, b))

# ê°„ì„  ì •ë³´ ë¹„ìš© ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
edges.sort()

# ê°„ì„  ì •ë³´ í•˜ë‚˜ì”© í™•ì¸í•˜ë©´ì„œ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰
for i in range(e):
    cost, a, b = edges[i]
    # find ì—°ì‚° í›„, ë¶€ëª¨ë…¸ë“œ ë‹¤ë¥´ë©´ ì‚¬ì´í´ ë°œìƒ Xìœ¼ë¯€ë¡œ union ì—°ì‚° ìˆ˜í–‰ -> ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— í¬í•¨!
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        total_cost += cost

print(total_cost)
```

3) í”„ë¦¼(Prim) - MST êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
: ì„ì˜ì˜ ì‹œì‘ì ì—ì„œ í˜„ì¬ê¹Œì§€ ì—°ê²°ëœ ì •ì ë“¤ì—ì„œ ì—°ê²°ì•ˆëœ ì •ì ë“¤ì— ëŒ€í•´, ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ì •ì ì„ ì—°ê²°í•˜ëŠ” ì •ì  ì„ íƒ ê¸°ë°˜ìœ¼ë¡œ ë™ì‘


1) í”„ë¦¼ì˜ í•µì‹¬ì€ íŠ¸ë¦¬ ì§‘í•©ì„ ë‹¨ê³„ì ìœ¼ë¡œ í™•ì¥í•˜ëŠ” ê²ƒì´ê³ , 

2) ìƒˆë¡œìš´ ì •ì ì„ ì—°ê²°í•  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ì •ì ì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ì•„ì§ ì—°ê²°ë˜ì§€ ì•Šì€ ì •ì ë“¤ì— ëŒ€í•œ ê°„ì„ ì„ ì¶”ê°€

>> Priority Queueë¥¼ ì´ìš©í•œ ìµœì†Œ í™ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆê³ , ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ê³¼ êµ¬í˜„ ë°©ì‹ì´ ìœ ì‚¬í•¨



ì‹œê°„ë³µì¡ë„ : O(ElogV)

* E : ê°„ì„ ì˜ ê°œìˆ˜

* V : ì •ì ì˜ ê°œìˆ˜



[í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ ë™ì‘ ë°©ì‹]
1) ì„ì˜ì˜ ì •ì ì„ ì‹œì‘ì ìœ¼ë¡œ ì„ íƒ

2) ì‹œì‘ì ì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ì •ì  ì¤‘ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ì •ì ì„ ì—°ê²°

3)-1 : 2ë²ˆ ê³¼ì •ì—ì„œ ì‹œì‘ì ê³¼ ì–´ë– í•œ ì •ì ë“¤ì´ ì—°ê²°ë¨

3)-2 : ì‹œì‘ì ê³¼ ì—°ê²°ëœ ì •ì ë“¤ì„ aì§‘í•©ì´ë¼ í•  ë•Œ, aì§‘í•©ì—ì„œ ê°ˆìˆ˜ ìˆëŠ” aì§‘í•©ì— ì†í•˜ì§€ ì•Šì€ ì •ì ë“¤ì— ëŒ€í•´ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ì •ì  ì—°ê²°

4) aì§‘í•©ì˜ í¬ê¸°ê°€ ëŠ˜ì–´ë‚¨(ì‹œì‘ì ì„ í¬í•¨í•œ aì§‘í•©ì— ìƒˆë¡œìš´ ì •ì ì„ ì—°ê²°í•¨) ìœ„ì˜ ê³¼ì •ì„ ëª¨ë“  ì •ì ì´ ì—°ê²°ë  ë•Œê¹Œì§€ ë°˜ë³µ


```
import heapq
import collections
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

n, m = map(int,input().split()) # ë…¸ë“œ ìˆ˜, ê°„ì„  ìˆ˜
graph = collections.defaultdict(list) # ë¹ˆ ê·¸ë˜í”„ ìƒì„±
visited = [0] * (n+1) # ë…¸ë“œì˜ ë°©ë¬¸ ì •ë³´ ì´ˆê¸°í™”

# ë¬´ë°©í–¥ ê·¸ë˜í”„ ìƒì„±
for i in range(m): # ê°„ì„± ì •ë³´ ì…ë ¥ ë°›ê¸°
    u, v, weight = map(int,input().split())
    graph[u].append([weight, u, v])
    graph[v].append([weight, v, u])


# í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜
def prim(graph, start_node):
    visited[start_node] = 1 # ë°©ë¬¸ ê°±ì‹ 
    candidate = graph[start_node] # ì¸ì ‘ ê°„ì„  ì¶”ì¶œ
    heapq.heapify(candidate) # ìš°ì„ ìˆœìœ„ í ìƒì„±
    mst = [] # mst
    total_weight = 0 # ì „ì²´ ê°€ì¤‘ì¹˜

    while candidate:
        weight, u, v = heapq.heappop(candidate) # ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì ì€ ê°„ì„  ì¶”ì¶œ
        if visited[v] == 0: # ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
            visited[v] = 1 # ë°©ë¬¸ ê°±ì‹ 
            mst.append((u,v)) # mst ì‚½ì…
            total_weight += weight # ì „ì²´ ê°€ì¤‘ì¹˜ ê°±ì‹ 

            for edge in graph[v]: # ë‹¤ìŒ ì¸ì ‘ ê°„ì„  íƒìƒ‰
                if visited[edge[2]] == 0: # ë°©ë¬¸í•œ ë…¸ë“œê°€ ì•„ë‹ˆë¼ë©´, (ìˆœí™˜ ë°©ì§€)
                    heapq.heappush(candidate, edge) # ìš°ì„ ìˆœìœ„ íì— edge ì‚½ì…

    return total_weight

print(prim(graph,1))
```
[ì°¸ê³ ]


[Python] ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ì°¾ëŠ” í¬ë£¨ìŠ¤ì¹¼(Kruskal) ì•Œê³ ë¦¬ì¦˜

ğŸ”Š ì´ë²ˆ í¬ìŠ¤íŒ…ì—ëŠ” ìµœê·¼ì— Pythonìœ¼ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ê³µë¶€í•˜ê¸° ì‹œì‘í•˜ë©´ì„œ ì•Œê²Œ ëœ ì—¬ëŸ¬ ì•Œê³ ë¦¬ì¦˜ì˜ ì›ë¦¬ì™€ Pythonìœ¼ë¡œ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ì†Œê°œí•´ë³´ë ¤ í•œë‹¤. í•„ìëŠ” ìµœê·¼ ì•Œê³ ë¦¬ì¦˜ ê³µë¶€ë¥¼ 'ë‚˜ë™

techblog-history-younghunjo1.tistory.com

[ì•Œê³ ë¦¬ì¦˜] í¬ë£¨ìŠ¤ì¹¼(Kruskal)ê³¼ í”„ë¦¼(Prim)

Goal MSTë€? í¬ë£¨ìŠ¤ì¹¼ì´ë€? í”„ë¦¼ì´ë€? ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— ì‚¬ìš©ëœ ìµœì†Œ ë¹„ìš©ì„ ì–´ë–»ê²Œ êµ¬í• ê¹Œ?  ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ì–´ë–»ê²Œ ë§Œë“¤ ìˆ˜ ìˆì„ê¹Œ? 1. í¬ë£¨ìŠ¤ì¹¼? í”„ë¦¼? MST? 1) MST(Minimum Spanning Tree) ì‹ ì¥

ongveloper.tistory.com



[ì•Œê³ ë¦¬ì¦˜] í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜(Prim Algorithm)

í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜(Prim Algorithm)  ì˜¤ëŠ˜ì€ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•´ ê³µë¶€í–ˆìŠµë‹ˆë‹¤. í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ ì£¼ì–´ì§„ ë¬´ë°©í–¥ ê·¸ë˜í”„ë‚´ì—ì„œ MSTë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.  í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ê³¼

deep-learning-study.tistory.com
