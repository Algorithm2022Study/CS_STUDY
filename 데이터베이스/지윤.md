# 관계형 데이터베이스(RDBMS)
## 데이터베이스를 사용하는 이유

기존에는 파일 시스템을 사용해 데이터를 관리했습니다. 그러나 파일 시스템에는 '데이터 중복', '데이터 불일치', '데이터 보안문제' 등 다양한 문제점을 가지고 있습니다. 데이터베이스를 사용하면 이러한 문제들을 어느 정도 해소할 수 있습니다.

## 관계형 데이터베이스의 개념과 장단점
> 테이블 기반 DBMS로, 테이블들의 집합으로 데이터들의 관계를 표현

- 2차원 테이블(Table) 형태로 이루어져 있으며, 이 테이블은 키(Key)와 값(Value)의 관계를 나타냄
- 이처럼 데이터의 종속성을 관계(Relationship)로 표현하는 것이 특징
-> 행과 열로 이루어진 각각의 테이블을 고유값(Primary Key)을 참조하여 서로 종속되는 관계를 표현
- 현재 많이 사용되는 관계 데이터 모델 DBMS는 Oracle, MySQL, SQL Server 등이 있음

`장점`
- 범용적이고 안정적이며 데이터의 일관성을 보장함
- 중복 데이터 최소화 (정규화)
- 복잡한 형태의 쿼리가 가능해서 원하는 데이터를 추출할 수 있음(Join 등의 연산 지원)

`단점`
- 테이블 간의 관계를 맺는 과정이 복잡함
- 대량의 데이터 입력, 조회시 성능이 저하됨
- 테이블 구조의 변경 시 많은 패널티가 따름

## DML, DDL, DCL

### DML (Data Manipulation Language)
> 데이터 조작어, 데이터베이스 테이블의 레코드를 CRUD (Create, Read, Update, Delete)

- SELECT : 데이터 조회
- INSERT : 데이터 삽입
- UPDATE : 데이터 수정
- DELETE : 데이터 삭제

### DDL (Data Definition Language) 
> 데이터 정의어, 데이터베이스 객체(table, view, index...)의 구조를 정의 (생성, 변경, 제거)

- CREATE : 데이터베이스, 테이블 생성
- ALTER : 테이블 수정
- DROP : 데이터베이스, 테이블 삭제
- TRUNCATE : 테이블 초기화

### DCL (Data Control Language)
> 데이터 제어어, 데이터베이스와 그 구조에 대한 접근 권한을 제공하거나 제거

- GRANT : 특정 사용자에게 특정 작업에 대한 수행권한 부여
- REVOKE : 특정 사용자에게 특정 작업에 대한 수행권한 박탈, 회수
- COMMIT : 트랜잭션 작업 결과 반영
- ROLLBACK : 트랜잭션 작업 취소 및 복구


## Key
> 검색, 정렬시 Tuple을 구분할 수 있는 기준이 되는 Attribute.

- 조건을 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별할 수 있는 유일한 기준이 되는 속성(Attribute)

### key의 특성

- 유일성 : 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질
- 최소성 : 꼭 필요한 최소한의 속성들로만 키를 구성함

-> 키는 릴레이션 간의 관계를 맺는 데에도 사용됨

### key의 종류

1. 슈퍼키(Super Key) : 튜플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합
	- 튜플을 유일하게 식별할 수 있는 값이면 모두 슈퍼키가 될 수 있음
    - 유일성은 만족하지만, 최소성은 만족하지 못함
    
2. 후보키(Candidate Key): 튜플을 유일하게 식별할 수 있는 속성의 `최소` 집합
	- 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 함
    - 유일성과 최소성을 만족
    
3. 기본키(Primary Key): 여러 후보키 중 하나를 선정하여 대표로 삼는 키
	- 후보키 중에서 선택한 `Main Key`
    - NULL 값을 가질 수 없음
    - 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없음
    
4. 대체키(alternate Key): 기본키로 선정되는 않은 후보키
	- 후보키가 두개 이상일 때 기본키를 제외한 나머지 후보키들을 말함

5. 외래키(foreign Key): 다른 릴레이션의 기본키를 참조하는 속성
	- 다른 릴레이션의 기본키를 참조하여 관계 데이터 모델의 특징인 릴레이션 간의 관계를 표현함
    - 참조되는(기본키) 값이 변경되면 참조하는(외래키) 값도 변경됨
    - NULL값과 중복 값 등이 허용됨

# Join
> 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법

- 두 가지 이상의 릴레이션을 연결해서 데이터를 검색하는 기법
- RDBMS에서는 릴레이션끼리 관계를 가지고 있는데, 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요

### INNER JOIN
![](https://velog.velcdn.com/images/yunva17/post/d74d5aa3-d580-4bef-8af2-e14629fff09a/image.png)
- 교집합으로, 기준 테이블과 join 테이블의 중복된 값을 보여줌

```INNER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP```

### LEFT OUTER JOIN
![](https://velog.velcdn.com/images/yunva17/post/4fabbf20-2665-4306-a9ef-df50850066af/image.png)
- 기준테이블값과 조인테이블과 중복된 값을 보여줌
- 왼쪽테이블 기준으로 JOIN을 한다고 생각

### RIGHT OUTER JOIN
![](https://velog.velcdn.com/images/yunva17/post/eac4fbf4-298e-4710-b791-e797173e93f3/image.png)
- LEFT OUTER JOIN과는 반대로 오른쪽 테이블 기준으로 JOIN

### FULL OUTER JOIN
![](https://velog.velcdn.com/images/yunva17/post/f4b46593-aab9-49f3-9da6-5d6d3268fe6e/image.png)

- 합집합으로, A와 B 테이블의 모든 데이터가 검색됨

### CROSS JOIN
![](https://velog.velcdn.com/images/yunva17/post/f5887d18-a34d-4211-a0ca-76ea3cf0c50e/image.png)

- 모든 경우의 수를 전부 표현해주는 방식
- A가 3개, B가 4개면 총 3*4 = 12개의 데이터가 검색됨

### SELF JOIN
![](https://velog.velcdn.com/images/yunva17/post/645eae54-6fde-4d63-969a-3bf7cd201cc4/image.png)

- 자기자신과 자기자신을 조인하는 것
- 자신이 갖고 있는 칼럼을 다양하게 변형시켜 활용할 때 자주 사용

# 이상 현상과 정규화

## 이상 현상
> 불필요한 데이터 중복으로 인해 릴레이션 조작 시 생기는 부작용 현상

- 삽입 이상 : 데이터를 삽입할 때 원하지 않은 값들도 함께 삽입되는 현상
- 갱신 이상 : 데이터를 수정할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상. 일관성이 위반됨
- 삭제 이상 : 데이터를 삭제할 때 의도와는 상관 없는 값들도 함께 삭제되는 현상. 정보 손실이 일어남


## 정규화
> 이상현상이 발생하는 릴레이션을 분해하여 이상현상을 없애는 과정

- 함수의 종속성 이론을 통해 데이터의 중복성을 최소화하고 일관성 등을 보장하여 데이터베이스의 품질과 성능을 향상키시는 과정
- 정규화 수준이 높을수록 유연한 데이터 구추기 가능하고 데이터의 정확성이 높아지는 반면, 물리적 접근이 복잡하고 너무 많은 조인으로 인해 조회 성능이 저하된다는 특징이 있음

### 정규화 목적 

- 데이터 구조의 안정성과 무결성 유지
- 데이터 모형의 단순화가 가능
- 효과적인 검색 알고리즘을 생성할 수 있음
- 데이터 중보글 배제하여 이상 발생을 방지하고 저장 공간을 최소화

### 정규화 과정

#### 1NF(제 1 정규형)

릴레이션에 속한 모든 도메인이 원자값만으로 되어있는 정규형

#### 2NF(제 2 정규형)

1NF를 만족하고, 부분 함수적 종속을 제거하여 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형

```
완전 함수적 종속 : 만약 (속성 A, 속성 B) -> 속성 C 일때, A->C, B->C 모두 성립될때 완전 함수적 종속이라 한다
부분 함수적 종속 : 만약 (속성 A, 속성 B) -> 속성 C 일때, A->C, B->C 중 하나만 성립될때(모두 성립 x) 부분 함수적 종속이라 한다
```

#### 3NF(제 3 정규형)

2NF를 만족하고, 이행적 함수 종속을 제거하는 정규형

```
이행적 종속 : A -> B, B -> C 의 종속관계에서 A -> C를 만족하는 관계를 의미한다
```


#### BCNF(Boyce-Codd 정규형)

결정자가 모두 후보키인 정규형(후보키가 아닌 결정자를 제거하는 정규형)

`BCNF의 제약 조건`
- 키가 아닌 모든 속성은 각 키에 대하여 완전 종속해야 한다
- 키가 아닌 모든 속성은 그 자신이 부분적으로 들어가 있지 않은 모든 키에 대해 완전 종속해야 한다
- 어떤 속성도 키가 아닌 속성에 대해서는 완전 종속 할 수 없다

#### 4NF(제 4 정규형)

다치 종속을 제거하는 정규형

#### 5NF (제 5 정규형)

릴레이션 R의 모든 조인종속이 R의 후보키를 통해서만 성립되는 정규형


### 반정규화
> 성능 향상을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정

- 의도적으로 정규화 원칙을 위배하는 행위
- 조인으로 인한 성능 저하가 예상되는 경우 반정규화를 실행
- 시스템의 성능이 향상되고 관리 효율성은 증가하지만, 데이터의 일관성과 정합성은 저하될 수 있음
- 반정규화를 과도하게 적용하면 성능을 저하시키고 무결성이 깨질 수 있음
- 반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가 등이 있음
## 트랜잭션
> 데이터베이스의 상태를 변화시키기 위해 수행되는 작업의 논리적 단위

### ACID
- Atomicity(원자성) : 트랜잭션에 해당하는 작업 내용이 (모두 성공했을 시) 모두 반영되거나, (하나라도 실패했을 시) 모두 반영되지 않아야 한다.
- Consistency(일관성) : 트랜잭션 처리 결과는 항상 데이터의 일관성을 보장해야 한다.
- Isolation(고립성) : 둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 각 트랜잭션은 서로 간섭 없이 독립적으로 수행되어야 한다.
- Durability(지속성) : 트랜잭션이 성공적으로 완료된다면, 그 결과가 데이터베이스에 영구적으로 반영되어야 한다.

- commit : 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산
- Rollback : 데이터베이스 내의 연산이 비정상적으로 종료되거나 정상적으로 수행이 되었다 하더라도 수행되기 이전의 상태로 되돌리기 위해 연산 내용을 취소할 때 사용하는 명령어

-> 상황이 주어지면 DB 측면에서 어떻게 해결할 수 있을지 대답할 수 있어야 함

### 트랜잭션 격리 수준(Transaction Isolation Level)
> 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준

#### Isolation level의 필요성

데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 한다.
따라서 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.
하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것이다.
그렇다고 해서, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 된다.
따라서 최대한 효율적인 Locking 방법이 필요함!

#### Isolation level 종류

1. Read Uncommitted (레벨 0)

- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층
- 트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함
- 데이터베이스의 일관성을 유지하는 것이 불가능함

```사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다```

2. Read Committed (레벨 1)

- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층
- 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
- Commit이 이루어진 트랜잭션만 조회 가능
- 대부분의 SQL 서버가 Default로 사용하는 Isolation Level임

```사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능함```

3. Repeatable Read (레벨 2)

- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
- 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
- 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
- MySQL에서 Default로 사용하는 Isolation Level

4. Serializable (레벨 3)

- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층
- 완벽한 읽기 일관성 모드를 제공함
- 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능

#### 선택 시 고려사항
- Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있음
- 동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨
- 레벨을 높게 조정할 수록 발생하는 비용이 증가함

#### 낮은 단계 Isolation Level을 활용할 때 발생하는 현상들

- Dirty Read
커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
한 트랜잭션 진행 중에 변경한 값을 다른 트랜잭션에서 읽을 때 발생한다. 커밋되지 않은 상태의 트랜잭션을 다른 트랜잭션에서 읽을 수 있을 때 발생하는 문제이다.
발생 Level: Read Uncommitted

- Non-Repeatable Read
한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상
한 트랜잭션에서 같은 값을 두 번 이상 읽었을 때 그 값이 다른 경우를 말한다. 한 트랜잭션 도중 다른 트랜잭션이 커밋되면 발생할 수 있는 문제이다.
발생 Level: Read Committed, Read Uncommitted

- Phantom Read
한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임
한 트랜잭션에서 같은 쿼리문을 두 번 이상 실행했을 때 새로운 데이터가 조회되는 경우를 말한다. A 트랜잭션 도중 B 트랜잭션에서 update 쿼리를 수행하고 커밋하더라도 A 트랜잭션에서 그 결과는 볼 수 없지만, A 트랜잭션 도중 B 트랜잭션에서 insert 쿼리를 수행할 경우 A 트랜잭션에서 처음에 안 보였던 새로운 데이터가 조회될 수 있다.
발생 Level: Repeatable Read, Read Committed, Read Uncommitted




## 인덱스(Index)
> 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

- 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
- 인덱스 생성 시 오름차순으로 정렬하기 때문에 정렬된 주소체계

`장점`
- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있음
- 전반적인 시스템의 부하를 줄일 수 있음

`단점`
- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요함
- 인덱스를 관리하기 위해 추가 작업이 필요함
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있음
- 중복이 많은 데이터에는 인덱스 추가를 안하는 게 좋음

`인덱스를 사용하면 좋은 경우`
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

### 인덱스 자료구조
- B+-Tree(B-Tree, B+Tree)
- Hash

### Clustered index, Non-Clustered index

- Clustered index
	- 테이블의 데이터를 지정된 컬럼에 대해 물리적으로 데이터를 재배열
	- 범위 검색에 강력함
	- 입력/수정/삭제 시에도 정렬을 수행하여 입력/수정/삭제 속도는 더 느림
	- 한 테이블당 하나만 존재
    
- Non-Clustered index
	- 루트 페이지와 리프 페이지로 구성되며, 리프 페이지는 데이터 그 자체
	- Clustered Index보다 검색 속도는 느리지만, 데이터의 입력/수정/삭제는 더 빠름
	- 한 테이블당 여러개가 존재할 수 있음

## NoSql
> 비관계형 데이터베이스

![](https://velog.velcdn.com/images/yunva17/post/6031fc04-e423-4d24-a2fa-0f2fe22be63c/image.png)

- 기존 RDBMS 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미함

`특징`
- RDBMS와 달리 데이터 간의 관계를 정의하지 않음
	- RDBMS는 데이터 관계를 외래키 등으로 정의하고 JOIN 연산을 수행할 수 있지만, NoSQL은 JOIN 연산이 불가능
- RDBMS에 비해 대용량의 데이터를 저장할 수 있음
- 분산형 구조임
	- 여러 곳의 서버에 데이터를 분산 저장해 특정 서버에 장애가 발생했을 때도 데이터 유실 혹은 서비스 중지가 발생하지 않도록 함
- 고정되지 않은 테이블 스키마를 가짐
	- RDBMS와 달리 테이블의 스키마가 유동적임. 데이터를 저장하는 칼럼이 각기 다른 이름과 다른 데이터 타입을 갖는 것이 허용됨


`장점`
- 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐
- 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능
- JOIN 처리가 없기 때문에 스케일 아웃을 통한 노드확장이 용이
- 비정형 데이터 구조 설계로 설계 비용 감소
- Big Data 처리에 효과적
- RDBMS에 비해 저렴한 비용으로 분산처리와 병렬 처리 가능

`단점`
- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
- 데이터 중복을 계속 업데이트 해야 함
- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)
- 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
- 많은 인덱스를 사용하려면 충분한 메모리가 필요. 인덱스 구조가 메모리에 저장
- 데이터 일관성이 항상 보장되지 않음

`NoSQL 데이터베이스 사용이 더 좋은 경우`
- 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)

### NoSQL의 종류
1. Key-Value Database
![](https://velog.velcdn.com/images/yunva17/post/c84e3158-8319-4c42-b60b-b74009a7b1cf/image.png)
출처: https://en.wikipedia.org/wiki/Key-value_database

- 기본적인 패턴으로 KEY-VALUE 하나의 묶음(Unique)으로 저장되는 구조로 단순한 구조이기에 속도가 빠르며 분산 저장 시 용이함
- Key 안에 (COLUMN, VALUE) 형태로 된 여러 개의 필드, 즉 COLUMN FAMILIES 가짐
Ex) Redis, Oracle NoSQL Database, VoldeMorte

2. Wide-Column Database
![](https://velog.velcdn.com/images/yunva17/post/ea8b1dcc-e39d-457e-a54b-6b6dd0c2a0b4/image.png)
출처: https://database.guide/what-is-a-column-store-database/

- 행마다 키와 해당 값을 저장할 때마다 각각 다른값의 다른 수의 스키마를 가질 수 있음
- 대량의 데이터의 압축, 분산처리, 집계 쿼리 (SUM, COUNT, AVG 등)및 쿼리 동작 속도 그리고 확장성이 뛰어난 것이 그 대표적 특징
EX) Hbase, GoogleBigTable, Vertica

3. Document Database
![](https://velog.velcdn.com/images/yunva17/post/9e1c4407-04c5-4af8-828e-a0a30d998179/image.png)
출처: https://inyl.github.io/programming/2017/05/09/database.html

- 테이블의 스키마가 유동적, 즉 레코드마다 각각 다른 스키마를 가질 수 있음
- 보통 XML, JSON과 같은 DOCUMENT를 이용해 레코드를 저장함
- 트리형 구조로 레코드를 저장하거나 검색하는 데 효과적
Ex) MongoDB, CouchDB, Azure Cosmos DB

4. Graph Database
- 데이터를 노드로(그림에서 파란, 녹색 원) 표현하며 노드 사이의 관계를 엣지(그림에서 화살표)로 표현
- 일반적으로 RDBMS 보다 성능이 좋고 유연하며 유지보수에 용이한 것이 특징
Ex) Neo4j, BlazeGraph, OrientDB




출처) 
https://github.com/gyoogle/tech-interview-for-developer/tree/master/Computer%20Science/Database
https://github.com/Seogeurim/CS-study/tree/main/contents/database
https://github.com/ham-study/cs-study-for-interview/blob/main/Database/Database.md
https://code-lab1.tistory.com/53
https://github.com/Seogeurim/CS-study/tree/main/contents/database
https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database
https://velog.io/@odh0112/Database-관계형-데이터베이스
https://github.com/ham-study/cs-study-for-interview/blob/main/Database/Database.md
