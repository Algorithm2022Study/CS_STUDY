# 네트워크

TCP 3-way-handshake & 4-way-handshake
TCP 와 UDP
HTTP 요청 방식 - GET, POST
HTTP 와 HTTPS

**TCP 3-way-handshake & 4-way-handshake**

연결을 성립하고 해제하는 과정

3 way handshake - 연결 성립

tcp는 정확한 전송을 보장해야 한다. 따라서 통신하기에 앞서, 논리적인 접속을 성립하기 위해

3way handshake과정 진행

1. 클라이언트가 서버에게 SYN패킷을 보낸다.(sequence: x)
2. 서버가 SYN(x)를 받고 클라이언트로 받았다는 신호인 ACK와 SYN패킷을 보낸다.

(sequence:y, ACK:x+1)

1. 클라이언트는 서버의 응답은 ACK(x+1)와 SYN(y)패킷을 받고 ACK(y+1)을 서버로 보낸다.
2. 이렇게 3번의 통신이 완료되면 연결이 성립

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a0926bc-d4e4-4d8d-aa81-c6f40c0c8180/Untitled.png)

4 way handshake - 연결 해제

연결 성립 후 모든 통신이 끝났다면 해제해야 한다.

1. 클라이언트는 서버에게 연결을 종료한다는 FIN플래그를 보낸다.
2. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다(이때 모든 데이터를 보내기 위해 close_wait상태가 된다)
3. 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN플래그를 클라이언트에게 보낸다.
4. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다

(아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다.)

#서버는 ACK를 받은 이후 소켓을 닫는다(CLOSED)

#TIME_WAIT시간이 끝나면 클라이언트도 닫는다(CLOSED)

이렇게 4번의 통신이 완료되면 연결이 해제된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd212efa-cf94-4887-a619-959b68c6dc5a/Untitled.png)

- 클라이언트에서 FIN패킷을 보내고, 서버에서 ACK패킷을 보낸 후 FINㅋ패킷을 보낸 상황이라고 가정합시다. 이때 클라이언트에서 ACK패킷을 전송했는데 서버에서 받지 못했다면 어떻게 될까요?
    
    첫번째는 서버에서 ACK패킷을 받지 못했다는 것을 클라이언트에게 알려주어 다시 패킷을 보내 줄 수 있을 것 같습니다.
    
    두번째는 TIME WAY상태인 클라이언트가 일정 시간이 되어 종료되는 상황입니다. 그렇게 되면 서버는 ACK패킷을 받지 못한채, 타임아웃으로 종료될 것 같습니다.
    

**TCP 와 UDP**

1. **TCP 프로토콜**

OSI 7계층에서 4계층인 전송계층에서 사용하는 프로토콜

신뢰성있는 데이터 통신 가능하게 함, 양방향 통신, 데이터를 순차 전송을 보장

TCP는 수신측의 버퍼 오버 플로우를 막기 위한 흐름제어와 네트워크 과부하를 장지하는 혼잡제어의 역할 수행

1. **UDP프로토콜**

TCP보다 신뢰성 떨어지지만 전송 속도가 일반적으로 빠른 프로토콜

서로 연결된 네트워크를 통해 패킷 데이터그램을 전달하는 목적으로 사용

실시간 전송이 필요한 서비스에 사용(실시간 유뷰트스트림)

1. **흐름제어**

전송자가 데이터를 만드는 속도와 수신자가 데이터를 사용하는 속도의 균형을 맞추는 넋

흐름제어를 하기 위해서 수신측의 수신 윈도우 변수를 이용

방법 1) STOP AND WAIT : 매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷 전송 

2)SLIDING WINDOW:송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법⇒ 송신측에서는 ACK프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다.

1. **혼잡제어**

공유자원인 네트워크망의 혼잡을 악화시켜 통신에 충돌이 나게 하는 것을 줄이고, 한정된 장된 자원을 잘 분배하여 원할히 돌아갈 수 있또록 제어하는 것

방법

1) AIMD방식: 네트워크에 문제가 없다면 혼잡 윈도우 크기를 1씩 증가시키고 혼잡하다면 절반으로 줄이는 방식 시간이 지남에 따라 윈도우 크기가 평형상태로 수렴 네트워크에 문제가 없는 상황에서 초반에 대역폭을 제대로 활용하는데 시간이 걸린다는 단점

2)SLOW START방식: 네트워크에 문제가 없다면 지수적으로 윈도우 크기를 늘리고 혼잡하다면 크기를 1로 만드는 방식 

1. **오류제어**

오류 검출과 재전송을 포함하며, ARQ(AUTOMATIC REPEAT REQUEST)기법을 사용하여 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구하는 것

방법

1)SOTP AND WAIT:전송한 패킷에 대한 ack를 받아야만 다음 패킷을 보냄

2)Go back N : 서정한 윈도우 크기만큼 상대측으로 데이터를 보냄, 중간에 에러가 나오면 에러가 나온 패킷부터 다시 윈도우 크기만큼 데이터를 보냄

3)selective repeat: 에러가 난 패킷만 재전송하는 방법, 손싱 측에서 데이터의 순서가 바뀌게 된다면 ack를 보내지 않음

- NETFLEX는 TCP일까 UDP일까?
    
    TCP이다. 고화질의 영상을 사용자가 시청하는것이 중요하기 떄문에, 실시간 전송이 중요한 UDP
    

- 흐름제어란 각 상대측 노드의 데이터 처리 속도 차이를 해결하는 방법
- 혼잡제어란 네트워크 상황에 맞게 데이터의 양을 제어하는 방법

**HTTP 요청 방식 - GET, POST**

GET은 조회를 위한 메소드,

조회 정보를 URI에 담아 요청하며 HTTP Body 사용x

Post는 생성을 위한 메소드로 데이터 생서정보를 http body에 담아 요청

get은 멱등성을 가지는 반면 post는 멱등성을 가지지 않는다.

*명등성: 여러번 요청한 결과가 한번 요청한 결과와 같은 특징

get메소드는 데이터를 조회하는 메소드이므로 멱등성을 띄고, post메소드는 데이터를 생성하는 메소드이므로 멱등성을 띄지 않는다.  patch메소드는 요청 데이터를 그대로 수정하는 경우는 멱등성을 띄지만, 데이터가 1씩 증가하는 그런 경우에는 멱등성 x

- 

**HTTP 와 HTTPS**

HTTP(HyperText Transfer Protocol)

인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다. ⇒ 보안 문제 해결 HTTPS

HTTPS(HyperText Transfer Protocol Secure)

인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

HTTPS는 텍스트를 공개키 암호화 방식으로 암호화 한다.

HTTPS도 무조건 안전한 건 아님, 브라우저에서 주의 요함, 안전하지 않은 사이트와 같은 알림으로 주의 받게 됨

12.01

[https://seokbeomkim.github.io/posts/http1-http2/](https://seokbeomkim.github.io/posts/http1-http2/)

- HTTP 1.1 VS HTTP 2.0

http1.1 은 기본적으로 연결 당 하나의 요청과 응답을 처리하기 때문에 동시전송 문제와 다수의 리소스를 처리하기에 속도와 성능 이슈를 가지고 있다.

RTT(round trip time)증가

**Head-Of-Line Blocking**

헤더가 크다 : 헤더에는 많은 메타 정보들이 저장, 

이 문제점들을 해결하기 위해 ui,프론트엔드 개발자는

이미지 스프라이트:여러 개의 이미지를 하나의 이미지로 합쳐서 관리하는 이미지

도메인 샤딩, CSS/JAVASCRIPT압축, Data URI 

HTTP/2.0이 등장하고 더 빠른 이유

multiplexed streams: 한 커넥션에 여러개의 메시지를 동시에 주고 받을 수 있음

요청이 커넥션 상에서 다중화 되므로 hol block이 발생하지 않음

stream prioritization(요청 리소스간 의존관계를 설정

header compression: header정보를 hpack압축 방식을 이용하여 압축 전송

http1.1과의 높은 수준의 호환성

페이지 로딩 속도 향상

[https://velog.io/@ragnarok_code/Network-CORS란](https://velog.io/@ragnarok_code/Network-CORS%EB%9E%80)

- CORS

cors: 한 도메인 또는 origin의 웹페이지가 다른 도메인을 가진 리소스에 액세스 할 수 있게 하는 보안 메커니즘

과정

cors요청시에는 미리 options주소로 서버가 cors를 허용하는지 물어본다

이때 access-control-request-method로 실제로 보내고자 하는 메서드를 알리고 access-control-request-headers로 실제로 보내고자 하는 헤더들을 알린다.

allow항목들은 request에 대응되는 것으로, 서버가 허용하는 메서드와 헤더를 응답하는데 사용된다. request랑 allow가 일치하면 cors요청이 이루어진다.

종류

simple request, preflight request,credential request, non-credential request

[https://velog.io/@jakezo/쿠키Cookie-세션Session-특징-및-차이](https://velog.io/@jakezo/%EC%BF%A0%ED%82%A4Cookie-%EC%84%B8%EC%85%98Session-%ED%8A%B9%EC%A7%95-%EB%B0%8F-%EC%B0%A8%EC%9D%B4)

- COOKIE & SESSION

쿠키

http 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일

특징

이름,값,만료일,경로 정보로 구성

클라이언트에 총300개 쿠키 저장가능

하나의 도메인 당 20개의 쿠키를 가질 수 있음

하나의 쿠키는 4kb까지 저장가능

ex)아이디,비번 자동 입력

동작순서

1.클라이언트가 페이지를 요청한다.

2.웹 서버는 쿠키를 생성한다.

1. 생성한 쿠키에 정보를 담아 http 화면을 돌려줄 때, 같이 클라이언트에게 돌려준다.
2. 4. 넘겨 받은 쿠키는 클라이언트가 가지고 있다가(로컬pc에 저장) 다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.
3. 동일 사이트 재방문시 클라이언트의 pc에 해당 쿠키가 있는 경우, 요청 페이지와 함꼐 쿠키 전송

세션

일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술

일정 시간: 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저를 종료하여 연결을 끝내는 시점

=방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 봄

특징

웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다.

쿠키보다 보안이 좋다.

각 클라이언트 고유 session id부여

동작순서

1.클라이언트가 페이지 요청

1. 서버는 접근한 클라이언트의 request-header필드인 cookie를 확인하여,

클라이언트가 해당 session id를 보냈는지 확인

1. session id가 존재하지 않는다면 서버는 session id를 생성해 클라이언트에게 돌려준다.
2. 서버에서 클라이언트로 돌려준 session id를 쿠키를 사용해 서버에 저장
3. 쿠키이름: jseesionid
4. 클라이언트는 재접속시 이 쿠키를 이용하여 sessionid값을 서버에 전달

ex) 화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지

[https://ehdvudee.tistory.com/34](https://ehdvudee.tistory.com/34)

- REST API

효율적인 http api를 설계/개발하기 위한 http api구현 방법론’

rest 아키텍처 스타일을 따르는 api

구성

자원-자원을 구별하는 ID는 HTTP URI

행위-HTTP METHOD사용

표현

특징: 확장성과 재사용성 높여 유지보수 용이

캐쉬가능

클라이언트 서버 구조 (서벙에서 API제공)

무상태 : 클라이언트 상태 정보 저장필요가 없이 API요청만 처리

유니폼 인터페이스 HTTP 표준만 준수하면 기술,환경,언어 종속적X, 모두 같은 인터페이스 제공

12.22

DNS - round robin 방식
웹 통신의 큰 흐름
IPv4 VS IPv6
로드밸런서
Blocking/Nonblocking&Synchronous/Asynchronous

[http://dailusia.blog.fc2.com/blog-entry-362.html](http://dailusia.blog.fc2.com/blog-entry-362.html)

DNS - round robin 방식

dns란

domain name system의 약자로 ip네트워크에서 사용하는 시스템

naver.com이 가리키는 ip를 브라우저에 반환한다. 즉 dns server는 웹서버 주소에 해당하는 ip주소 테이블을 가지고 있는 서버 

dns 과정

1.DNS Query

dns 서버에서 domain name을 이용하여 ip를 받아온다.

이때 domain name server에 접속하는 유저에 대하여 round robin 방식으로 ipfmf gkfekd

1. IP Communication

ip를 받아온 유저는 리퀘스트 메시지 발송을 통하여 정상적으로 네트워크 통신을 실시한다.

dns round robin

dns 서버 구성 방식 중 하나로 domian 에 대한 ip요청 쿼리 시 round-robin 방식으로 ip를 반환합니다.

round robin: 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로 프로세스들 사이에 우선순위를 두지 않고 순서대로 시간단위로 cpu를 할당하는 방식의 cpu 스케줄링 알고리즘

각 프로세스에 일정시간을 할당하고, 할당된 시간이 지나면 프로세스는 잠시 보류한 뒤 다른 프로세스에게 기회를 주고 또 그 다음 프로세스에게 하는 식으로 돌아가며 기회를 부여하는 운영방식

round robin형식으로 구성할 경우 로드 밸런서가 필요없다. 부하에 대한 걱정을 할 필요가 없다 ⇒ 자동적으로 시간에 따라서 스케쥴링이 변환되기 때문에

round robin 단점

1. 서버의 수 만큼 공인 ip주소가 필요
2. 균등하게 분산되지 않는다: 
3. 서버가 다운되도 확인이 불가능하다 

유저들이 간혹 다운된 서버로 연결이 되기도 한다.

극복 방법

다중화 구성방식

AP 서버에서 VIP를 부여하여 다중화를 구성한다. 각 AP서버를 HEALTH CHECK후 이상이 감지되면 VIP를 정상 AP서버로 인계하는 방식

DNS Server Table에 실시간으로 AP서버의 상태를 확인할 수 있는 칼럼 및 함수를 추가하여 요청될 경우 서버 상태를 확인하여 우회 루트를 제공하거나 에러를 전송하는 방식

가중치 편성 방식

각각의 웹 서버에 가중치를 가미해서 분산 비율을 변경한다. 물론 가중치가 큰 서버일수록 빈번하게 선택되므로 처리능력이 높은 서버는 가중치를 높게 설정하는 것이 좋다.

로드밸런서를 도입하여 최소 연결 방식

접속 클라이언트 수가 가장 적은 서버를 선택한다. 로드밸런서에서 실시간으로 connection수를 관리하거나 각 서버에서 주기적으로 알려주는 것이 필요하다.

[https://yaelimeee.tistory.com/50](https://yaelimeee.tistory.com/50)

웹 통신의 큰 흐름

웹 통신

클라이언트: 사용자가 서버에 접속하기 위해 사용하는 프로그램 또는 소비스

서버: 클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는 컴퓨터 시스템

웹 통신 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9cd8707c-025d-4013-a228-e812c9b5e8ac/Untitled.png)

사용자가 웹 브라우저를 통해 URL을 입력한다

입력된 URL중 도메인 네임을 DNS서버에서 검색한다

DNS 서버에서 해당 도메인 네임에 해당하는 IP주소를 찾아 사용자가 입력한 URL정보와 함께 전달한다

웹페이지 URL정보와 전달받은 IP주소를 이용해 HTTP요청 메시지를 생성한다

요청은 TCP를 통해 서버로 전송된다

서버는 클라이언트의 요청을 받고 응답을 전송한다

주소창에 특정 url을 입력하면 일어나는 일

1.브라우저

url에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.

조사된 의미에 따라 http request메시지를 만든다.

만들어진 메시지를 웹 서버로 전송한다.

2.프로토콜 스택, LAN 어댑터

프로토콜 스택(운영체제에 내장된 네트워크 제어용 소프트웨어)이 브라우저로부터 메시지를 받는다

브라우저로부터 받은 메시지를 패킷 속에 저장한다

그리고 수신처 주소 등의 제어정보를 덧붙인다

그런 다음 패킷을 LAN어댑터에 넘긴다

LAN어댑터를 다음 Hop의 MAC주소를 붙인 프레임을 전기신호로 변환시킨다.

신호를 LAN케이블에 송출시킨다.

3.허브,스위치,라우터

LAN어댑터가 송신한 프레임은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다. 라우터는 패킷을 프로바이터(통신사)에 전달한다

인터넷으로 들어가게 된다

4.엑세스 회선, 프로바이더

패킷은 인터넷의 입구에 있는 액세스 회선에 의해 POP까지 우난된다.

수많은 고속 라우터들 사이로 패킷이 목적지를 향해 흘러가게 된다.

POP를 거쳐 인터넷의 핵심부로 들어가게 된다

5.방화벽,캐시서버

패킷은 인터넷 핵심부를 통과하여 웹 서버측의 LAN에 도착한다.

기다리고 있떤 방화벽이 도착한 패킷을 검사한다.

패킷이 웹 서버까지 가야하는지 가지 않아도 되는지를 판단하는 캐시서버가 존재한다.

6.웹서버

패킷이 물리적인 웹서버에 도착하면 웹 서버의 프로토콜 스택은 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘긴다.

메시지를 받은 웹 서버 애플리케이션은 요청 메시지에 따른 데이터를 응답 메시지에 넣어 클라이언트로 회송한다.

왔던 방식대로 응답 메시지가 클라이언트에게 전달된다.

IPv4 VS IPv6

| 구분 | ipv4 | ipv6 |
| --- | --- | --- |
| 주소 길이 | 32비트 | 128비트 |
| 표시 방법 | 8비트씩 4부분 10진수 표시 | 16비트 8부분 16진수로 표시 |
| 주소 개수 | 약43억개 | 2^128개 |
| 주소할당 방식 | A,B,C,D등의 클래스 단위 비순차 할당 | 네트워크 규모,단말기수에 따라 순차할당 |
| 브로드캐스트 주소 | 있음 | 없음 |
| 헤더 크기 | 가변 | 고정 |
| QoS 제공 | 미흡 | 제공 |
| 보안 | IPSec 프로토콜 별도 설치 | IPSec 자체 지원 |
| 서비스 품질 | 제한적 품질 보장 | 확장된 품질 보장 (트래피긍ㄹ 효과적으로 분휴할 수 있는 기능제공) |
| Plug & Play | 불가 | 가능 |

[https://velog.io/@yanghl98/OS운영체제-로드밸런싱-Load-Balancing-정의-종류-알고리즘](https://velog.io/@yanghl98/OS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-Load-Balancing-%EC%A0%95%EC%9D%98-%EC%A2%85%EB%A5%98-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
로드밸런서

로드 밸런싱

네트워크 또는 서버에 가해지는 로드를 분산 해주는 기술

중앙처리장치 혹은 저장장치와 같이 컴퓨터 자원들에게 작업을 나누는 것을 의미

Load Balancing의 필요성

로드밸런시응ㄴ 여러 대의 서버를 두고 서비스를 제공하는 분산 처리 시스템에서 필요한 기술이ㅇ기술이다.  

증가한 트래픽에 대처할 수 있는 방법

1) scale-up: 서버 자체의 성능을 확장하는 것

2) scale-out: 기존 서버와 동일하거나 낮은 성능의 서버를 두 대 이상 증설하여 운영하는 것

cpu가 i3인 컴퓨터를 여러 대 추가 구입해 운영하는 것 → 이 경우 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드밸런싱이 필요

로드밸런서

로드밸런싱 기술을 제공하는 서비스 또는 장치

클라이언트와 네트워크 트래픽이 집중되는 서버들 또는 네트워크 허브 사이에 위치함

종류

1)L4 Load Balancing: 전송계층에서 로드 분산, ip주소나 포트번호, mac주소 등에 따라 트래픽을 나누고 분산처리가 가능하다.

2) L7 Load Balancing: 애플리케이션 계층에서 로드를 분산하다. oOSI 7계층의 프로토콜을 바탕으로도 분산 처리가 가능하다.

로드밸런싱 알고리즘

라운드로빈 방식: 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식

IP 해시 방식 등..

[https://velog.io/@wonhee010/동기vs비동기-feat.-blocking-vs-non-blocking](https://velog.io/@wonhee010/%EB%8F%99%EA%B8%B0vs%EB%B9%84%EB%8F%99%EA%B8%B0-feat.-blocking-vs-non-blocking)
Blocking/Nonblocking&Synchronous/Asynchronous

synchronous 동기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/53dd5921-f373-4fcf-8afd-3e8a67601f01/Untitled.png)

thread1이 작업을 시작하고 task1이 끝날때까지 기다렸다 task2를 시작한다.

작업 요청을 했을 때 요청의 결과값을 직접 받는 것이다.

요청의 결과값이 return값과 동일하다

호출한 함수가 작업 완료를 신경 쓴다

asynchronous 비동기

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae81c105-d8a1-4395-af60-39332d80e50b/Untitled.png)

thread1이 작업을 시작시키고, 완료를 기다리지 않고, thread1은 다른 일을 처리할 수 있다

작업 요청을 했을 때 요청의 결과값(return)을 간접적으로 받는 것이다.

요청의 결과값이 return값과 다를 수 있다

해당 요청 작업은 별도의 스레드에서 실행된다

콜백을 통한 처리가 비동기 처리라고 할 수 있다

호출된 함수(callback 함수)가 작업 완료를 신경쓴다

bocking

요청한 작업을 마칠 때까지 계속 대기한다

즉시 return한다

return 값을 받아야 끝난다

thread 관점으로 본다면, 요청한 작업을 마칠 떄까지 계속 대기하며 return값을 받을때까지 한 trhead를 계속 사용/대기 한다.

non-blocking

요청한 작업을 즉시 마칠 수 없다면 즉시 return한다

thread관점으로 본다면, 하느이 thrad가 여러 개의 io를 처리 가능하다

blocking/non-blocking

호출되는 함수가 바로 return하느냐 마느냐가 관심사

 호출된 함수가 바로 return해서 호출한 함수에게 제어권을 넘겨주고

호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있으면 non-blocking

호출된 함수가 자신의 작업을 모두 마칠떄까지

호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만들면 blocking

동기/비동기

호출되는 함수의 작업 완료 여부를 누가 신경쓰느냐가 관심사

호출되는 함수에게 callback을 전달해서 호출되는 함수의 작업이 완료되면

호출되는 함수가 전달받은 callback을 실행하고, 호출한 함수는 작업 완료 여부를 신경쓰지 않는다면 비동기이다.

호출하는 함수가 호출되는 함수의 작업 완료 후 return을 기다리거나

호출되는 함수로부터 바로 return 받더라도 작업 완료 여부를 호출한 함수 스스로 확인하며 신경 쓴다면 동기디ㅏ.
